# recursion-scala

Basic:
1. Write a recursive function that takes a list of integers and returns the sum of all integers.
2. Write a recursive function max that takes a list of integers and returns the largest integer.
3. Write a recursive function that filters list of integers.
4. Write a recursive function that returns the factorial of a number.
5. Write a recursive function that calculates n-th fibonacci number.
6. Write a recursive exponentiation function that raises a base by a power.
7. Write a recursive function to reverse a string.
8. Write a recursive function that checks if a string is a palindrome. Returns true or false.
9. Write a function that computes the Greatest Common Divisor of two numbers.

Intermediate:
1. Write the Ackermann function
2. Write a function that finds the index of a value in a sorted list.
3. Implement quick sort
4. Write a recursive function which verifies the balancing of parentheses in a string
5. Write a function that computes the elements of Pascalâ€™s triangle by means of a recursive process.
6. Find the highest sum of non-consecutive numbers
7. Find a pair in the array that would add up to the given sum
8. Find the longest increasing sub-sequence
9. Generate all permutations of a given string

Advance:
1. Solve Tower of Hanoi problem
2. Write a recursive function that counts how many different ways you can make change for an amount, given a list of coin denominations. For example, there are 3 ways to give change for 4 if you have coins with denomiation 1 and 2: 1+1+1+1, 1+1+2, 2+2. Do this exercise by implementing the countChange function in Main.scala. This function takes an amount to change, and a list of unique denominations for the coins. Its signature is as follows: def countChange(money: Int, coins: List[Int]): Int Once again, you can make use of functions isEmpty, head and tail on the list of integers coins.